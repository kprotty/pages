---
layout: default
title: "Atomics and Memory Ordering"
description: "Getting this released happened-before I observed any tpyos"
---

Atomic operations and memory orderings are often misunderstood or never understood. Personally, this was the result of constrained explanations, misguided discussion, and the use of formal language that I couldn't easy reason with. My assumption is that these issues have bitten quite a few others as well when trying to learn about this stuff. The goal of this post is to present the model of how I reason about this topic in a way that would've helped me understand when first learning. If it helps you, cool. If not, whatever. Those looking for a full explanation should read the memory models for whatever they're targetting. In this case, I'll be going off of [LLVM's Atomic Memory Model](https://llvm.org/docs/Atomics.html).

## Atomic and Shared Memory

In the age where CPUs are hitting sequential compute gains, many have looked into [superscalar](https://en.wikipedia.org/wiki/Superscalar_processor) compute -- using multiple distinct compute units. 

First, lets get some definitions out of the way:

* **Parallelism**: things happening at the same time
    * Example: two people; each doing their own task. 
* **Concurrency**: multiple things happening, but not necessarily at the same time
    * Example: one person; switching between tasks
* **Atomicity**: things appearing to happen in its entirety with no observable partial states.
    * Example: I appear to have written this blog atomically if you don't look at my commits.

> With that background, atomic operations can then be described as procedures which are observed to complete. Regarding computers, this is important for writing code in a preemptively scheduled environment; where your program can be paused at any given point to go work on something else. You need this in order to reliably implement parallel and concurrent algs.



Data processing hardware (CPUs) provide atomic instructions to do this with memory shared between multiple concurrent hardware instances (CPU cores). These extend the basic memory interactions to be safe to perform in parallel ("[soundly](#Volatile-and-Soundness)") and free from internal concurrency ("uninterruptable/atomicity"). The 3 primary atomic abstractions are as follows:

* **Loads**: 